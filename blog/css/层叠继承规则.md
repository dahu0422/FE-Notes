# _CSS_ 层叠继承规则

## 层叠规则

_CSS_ 是 _Cascading Style Sheets_ 的缩写，这暗示层叠（_cascade_）的概念是很重要的。

在最基本的层面上，它表明 _CSS_ 规则的顺序很重要，但它比那更复杂。

什么选择器在层叠中胜出取决于三个因素（这些都是按重量级顺序排列的，前面的的一种会否决后一种）：

- 重要性（_Importance_）
- 专用性（_Specificity_）
- 源代码次序（_Source order_）

### 重要性

在 _CSS_ 中，有一个特别的语法可以让一条规则总是优先于其他规则： **_!important_** 。

知道 _!important_ 存在是很有用的，这样当你在别人的代码中遇到它时，你就知道它是什么了。

但是！建议你千万不要使用它，除非你绝对必须使用它。您可能不得不使用它的一种情况是，当您在修改某个组件样式时，你不能编辑该组件核心的 _CSS_ 模块，又或者你确实想要重写一种不能以其他方式覆盖的样式。

但是，如果你能避免的话，不要使用它。由于 _!important_ 改变了层叠正常工作的方式，因此调试 _CSS_ 问题，尤其是在大型样式表中，会变得非常困难。

### 专用性

专用性基本上是衡量选择器的具体程度的一种方法，主要是指它能匹配多少元素。

元素选择器 < 类型选择器 < ID 选择器 < 内联样式

一个选择器具有的专用性的量可以用四种不同的值（或组件）来衡量的，它们可以被认为是**千位，百位，十位和个位**，在四个列中的四个简单数字：

- 千位：如果声明是在 **_style_** 属性中该列加 _1_ 分（这样的声明没有选择器，所以它们的专用性总是 _1000_）否则为 _0_。
- 百位：在整个选择器中每包含一个 **_ID_** 选择器就在该列中加 _1_ 分。
- 十位：在整个选择器中每包含一个**类选择器**、**属性选择器**、或者**伪类**就在该列中加 _1_ 分。
- 个位：在整个选择器中每包含一个**元素选择器**或**伪元素**就在该列中加 _1_ 分。

> 注：通用选择器（\*）, 复合选择器（+、>、~、空格）和否定伪类（:not）在专用性中无影响。

举个例子：

| **选择器**                                  | 千位 | 百位 | 十位 | 个位 | 合计值 |
| ------------------------------------------- | ---- | ---- | ---- | ---- | ------ |
| h1                                          | 0    | 0    | 0    | 1    | 0001   |
| #indentifier                                | 0    | 1    | 0    | 0    | 0100   |
| h1 + p::first-letter                        | 0    | 0    | 0    | 3    | 0003   |
| li > a[href*=” zh-CN”] > .inline-warning    | 0    | 0    | 2    | 2    | 0022   |
| 没有选择器, 规则在一个元素的 _style_ 属性里 | 1    | 0    | 0    | 0    | 1000   |

### 源代码次序

如果多个相互竞争的选择器具有相同的重要性和专用性，那么第三个因素将帮助决定哪一个规则获胜，也就是说，选择哪一个选择器取决于源码顺序。

例如：

```css
p {
  color: red;
}

p {
  color: blue;
}
```

不过有一点大家需要注意的是，当多个 _CSS_ 规则匹配相同的元素时，它们都被应用到该元素中。只不过后面因为层叠规则被层叠掉了而已。打开 _Elements > Styles_ 我们就能看到：

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2021-09-18-014022.png" alt="image-20210918094021662" style="zoom:50%;" />

## 继承规则

所谓继承，就是应用于某个元素的一些属性值将由该元素的子元素继承，而有些则不会。

究竟哪些属性能够被子元素继承，可以参阅：*https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference*

_CSS_ 为处理继承提供了四种特殊的通用属性值：

- _inherit_：该值将应用到选定元素的属性值设置为与其父元素一样。
- _initial_：该值将应用到选定元素的属性值设置为与浏览器默认样式表中该元素设置的值一样。如果浏览器默认样式表中没有设置值，并且该属性是自然继承的，那么该属性值就被设置为 _inherit_。
- _unset_：该值将属性重置为其自然值，即如果属性是自然继承的，那么它就表现得像 _inherit_，否则就是表现得像 _initial_。
- _revert_：如果当前的节点没有应用任何样式，则将该属性恢复到它所拥有的值。换句话说，属性值被设置成自定义样式所定义的属性（如果被设置）， 否则属性值被设置成用户代理的默认样式。

> 注： _initial_ 和 _unset_ 不被 _IE_ 支持。

**继承的就近原则**

由于属性值是由继承而来，所以属性值会继承离自己近的那个元素的属性。例如：

```html
<div class="one">
  <div class="two">
    <p>Lorem ipsum dolor sit amet.</p>
  </div>
</div>
```

```css
.two {
  color: blue;
}

.one {
  color: red;
}
```

在上面的示例中，_two_ 比 _one_ 更加接近 _p_，所以最终采用的是 _two_ 的 _color_ 值。段落呈现蓝色。

## 真题解答

- 请简述一下 _CSS_ 中的层叠规则

> 参考答案：
>
> _CSS_ 中当属性值发生冲突时，通过层叠规则来计算出最终的属性值，层叠规则可以分为 _3_ 块：
>
> - 重要性（_Importance_）：_!important_ 设置该条属性值最重要，但是一般不推荐使用。
> - 专用性（_Specificity_）：专用性主要是指它能匹配多少元素，匹配得越少专用性越高。
> - 源代码次序（_Source order_）：在重要性和专用性都一致的情况下，属性值取决于源代码的先后顺序。

-_EOF_-
