# 数据类型
JavaScript共有八种数据类型：
- 基本数据类型：Undefined、Null、Boolean、Number、String、Symbol、BigInt
- 引用数据类型：Object

基本数据类型的值被称为**原始值**或简单值，引用数据类型的值被称为**引用值**或复杂值。
## 原始值 VS 引用值
原始值是表示 JavaScript 中可用的数据或信息的**最底层形式**或最简单形式，是不可细化的。

也就是说，数字是数字，字符是字符，布尔值是 true 或 false，null 和 undefined 就是 null 和 undefined。这些值本身很简单，不能够再进行拆分。由于原始值的数据大小是固定的，所以**原始值的数据是存储于内存中的栈区里面的**。

在 JavaScript 中，对象就是一个引用值。因为对象可以向下拆分，拆分成多个简单值或者复杂值。引用值在内存中的大小是未知的，因为引用值可以包含任何值，而不是一个特定的已知值，所以**引用值的数据都是存储于堆区里面**。

两者区别：
1. 访问方式
   - 原始值：访问到的是值
   - 引用值：访问到的是引用地址
2. 比较方式
   - 原始值：比较的是值
   - 引用值：比较的是地址
3. 动态属性
   - 原始值：无法添加动态属性
   - 引用值：可以添加动态属性
4. 变量赋值
   - 原始值：赋值的是值
   - 引用值：赋值的是地址

## 包装对象
原始值没有方法，却能像有方法一样使用，是因为在原始值上访问属性是，JavaScript会**自动将值包装进对象中**，并访问对象上的属性。
```javascript
let str = 'hello JavaScript'
str.includes('t')
```
执行 `str.includes(t)` 时会隐式创建了一个 `String` 对象，调用该对象原型链上的 `String.prototype.includes()` 方法。

## 原始数据类型
### Symbol
用于表示**唯一**的值，常用作对象的键名。它的引入为了解决两个问题：
1. 唯一性：Symbol类型的值是唯一的，即使创建的时传入相同的描述符，每次创建的Symbol值也不相等。使得Symbol非常适合做对象属性的唯一表示符，避免了属性名冲突。
  ```javascript
  let sys1 = Symbol('descripttion')
  let sys2 = Symbol('descripttion')
  console.log(sys1 === sys2) // false
  ```
2. 私有性：虽然JavaScript没有严格意义上的私有成员概念，但通过Symbol定义的对象属性默认是不可枚举的，可以来模拟对象私有属性。
  ```javascript
  let obj = {a: 'a'}
  let sysKey = Symbol('key')
  obj[sysKey] = 'Some value'

  obj[sysKey] // Some value；不能直接用点操作符访问，要使用方括号
  obj // {a: 'a', Symbol(key): 'Some value'}
  Object.keys(obj) // ['a']
  ```
### BigInt
用于表示任意大小的整数的一种内置对象，是ECMAScript(ES2020)新增的。以解决`Number`类型在处理极大或极小整数时精度丢失的问题。
## 引用数据类型
### Object
### Array
### Function
### Map
`Map`对象是键值对的集合，`Map`中的键可以是**任何类型**并且是**唯一**的。

通过`set(key, value)`方法将数据存储进`Map`对象。`Map`对象按键值对迭代后形成一个[key, value]的数组，迭代顺序与插入顺序一致。  
### Set
`Set`对象是值的集合，`Set`中的值是唯一的。迭代顺序与插入顺序一致。
### WeakMap
`WeakMap`对象是键值对的集合，其中的键必须是对象或`Symbol`，值可以是任意类型。

`WeakMap`中的键是被**弱引用**的，一个对象如果作为WeakMap的键存在，不会阻止该对象被**垃圾回收**。
### WeakSet